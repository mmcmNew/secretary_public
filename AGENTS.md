# Codex Agent

The application will be available at `https://localhost:5100`.

To start the backend in development mode run:

```bash
python server/run.py --mode development
```

To work on the React client:

```bash
cd client
npm install
npm run dev
```

Frontend: React  
Backend: Flask

---

## Архитектура и основные контексты (агенты) клиента

В клиентской части приложения используются следующие ключевые контексты (агенты), реализованные через React Context API и Redux:

### 1. ErrorProvider (`contexts/ErrorContext.jsx`)
- Глобальный обработчик ошибок и уведомлений.
- Позволяет показывать сообщения об ошибках и успехах через Material-UI Snackbar/Alert.
- Используется как самый внешний провайдер.

### 2. Auth (authSlice в Redux)
- Управляет состоянием аутентификации пользователя, хранит токены, обеспечивает автоматическое обновление access token.
- Используется для защиты маршрутов и передачи информации о пользователе.
- Интегрирован с axios для автоматического добавления токена авторизации к запросам.

### 3. UpdateWebSocketProvider (`components/DraggableComponents/UpdateWebSocketContext.jsx`)
- Подключается к WebSocket `/updates` для получения обновлений данных (например, изменения задач).
- Хранит версии данных и реагирует на события типа `data_updated`, `task_changed`.

### 4. AudioProvider (`contexts/AudioContext.jsx`)
- Глобальный менеджер воспроизведения аудио (очередь, приоритеты, проигрывание звуковых уведомлений).

### 5. ContainerProvider (`components/DraggableComponents/ContainerContext.jsx`)
- Управляет состоянием всех "контейнеров" (доков, окон) на рабочем столе пользователя.
- Хранит данные о расположении, минимизации, порядке, темах, активных контейнерах и т.д.
- Предоставляет методы для создания, закрытия, минимизации, перемещения и обновления контейнеров.

### 6. TasksProvider (`components/ToDo/hooks/TasksContext.jsx`)
- Управляет задачами, списками задач, проектами, полями задач, выбранными задачами и списками.
- Предоставляет CRUD-операции для задач и списков, а также методы для работы с календарём и типами задач.

### 7. AntiScheduleProvider (`components/ToDo/hooks/AntiScheduleContext.jsx`)
- Контекст для режима "Антирасписание".
- Предназначен для планирования отдыха, чтобы пользователь мог явно выделять и отслеживать периоды отдыха.

### 8. FocusMode (обычно реализуется через компоненты в `Antischedule/FocusMode.jsx` и связанные хуки)
- Контекст и компоненты для режима фокусировки.
- Используется для отслеживания, на что было потрачено время в течение дня (time tracking).

### 9. WebSocketProvider (`components/Chat/WebSocketContext.jsx`)
- Контекст для чата, подключается к WebSocket `/chat`.
- Хранит сообщения, файлы, предоставляет методы для отправки сообщений и транскрипций.

---

## Пример вложенности провайдеров

В файле `App.jsx` провайдеры вложены следующим образом:

```jsx
<ErrorProvider>
  <UpdateWebSocketProvider>
    <AudioProvider>
      <ContainerProvider>
        <TasksProvider>
          <AntiScheduleProvider>
            <Router>
              <AppRoutes />
            </Router>
          </AntiScheduleProvider>
        </TasksProvider>
      </ContainerProvider>
    </AudioProvider>
  </UpdateWebSocketProvider>
</ErrorProvider>
```

---

## Backend (Flask): основные "агенты"

- Используются Flask Blueprints для разделения логики (main, tasks, dashboard, journals, twitch, ai_routes, messengers, admin, subscription).
- Контекст запроса (`flask.g`) используется для хранения информации о пользователе, правах доступа, подписках (см. `auth_middleware.py`).
- WebSocket-агенты реализованы через Flask-SocketIO (`/chat`, `/updates`).
- JWTManager управляет аутентификацией и загрузкой пользователя.

---

## Кратко

- **Контексты (агенты)** — это глобальные провайдеры состояния, которые обеспечивают работу ключевых функций приложения: аутентификация (через Redux), обработка ошибок, WebSocket, аудио, задачи, контейнеры, антирасписание (для отдыха), FocusMode (для трекинга времени) и чат.
- **Backend** использует Blueprints и контекст запроса для разграничения и управления логикой.

---

Если нужно добавить описание конкретного контекста или агента — уточните, и я дополню!

---

## Календарь

Календарь реализован на основе компонента [FullCalendar](https://fullcalendar.io/) и тесно интегрирован с системой задач. Основные возможности:

- **Визуализация задач**: Все задачи с датами отображаются в календаре как события. Поддерживаются различные виды (месяц, неделя, день, список).
- **Drag & Drop**: Задачи можно перетаскивать между днями, изменять длительность, создавать новые задачи прямо из календаря.
- **Редактирование**: При клике на событие открывается диалог для просмотра и редактирования задачи, включая подзадачи и дополнительные поля.
- **Повторяющиеся задачи**: Для задач с интервалом (ежедневные, еженедельные и т.д.) используется rrule, что позволяет создавать серии событий.
- **Списки и фильтрация**: Можно отображать задачи из разных списков, фильтровать по статусу, приоритету и другим параметрам.
- **Синхронизация**: Все изменения мгновенно синхронизируются с сервером и другими клиентами через WebSocket.

### Настройки календаря
- Интервал времени (slotDuration)
- Диапазон отображаемого времени (например, с 8 до 24)
- Смещение времени (timeOffset) для поддержки разных часовых поясов
- Переключение между отображением фоновых задач и обычных

---

## Override-задачи (экземпляры повторяющихся задач)

**Override** — это механизм, позволяющий изменять отдельные экземпляры повторяющихся задач, не затрагивая всю серию.

### Как это работает:
- **Повторяющаяся задача** (серия) задаётся с помощью rrule (например, "каждый понедельник") на сервере и на клиент передается набор задач.
- Если нужно изменить только один экземпляр (например, перенести задачу только на одну дату или изменить её параметры), создаётся override.
- Override хранит изменённые поля (например, новую дату, статус, название) только для конкретного дня.
- В интерфейсе можно переключаться между серией и отдельными экземплярами (overrides), а также просматривать список всех изменённых экземпляров.

### Backend
- Модель `TaskOverride`:
  - `id` — идентификатор override
  - `parent_task_id` — ссылка на основную задачу (серию)
  - `user_id` — пользователь-владелец
  - `date` — дата экземпляра, к которому относится override
  - `type` — тип override (`modified` — изменён, `skip` — пропущен)
  - `data` — JSON с изменёнными полями (start, end, title, status и т.д.)

- API:
  - `POST /tasks/override` — создать override
  - `PATCH /tasks/override/<id>` — обновить override
  - `DELETE /tasks/override/<id>` — удалить override
  - `GET /tasks/override/<id>` — получить override

### Пример использования
- Есть задача "Тренировка" каждый понедельник.
- В один из понедельников пользователь переносит тренировку на вторник — создаётся override только для этой даты.
- В календаре этот экземпляр будет отличаться от остальных, а серия останется неизменной.
