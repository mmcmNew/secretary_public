import{ad as t}from"./mui-fHG9gkAl.js";import{V as e}from"./index-CeQK5UPz.js";import"./index-CvSG9YTx.js";function n(t){if(t)throw t}var r,o;const i=t(function(){if(o)return r;o=1;var t=Object.prototype.hasOwnProperty,e=Object.prototype.toString,n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=function(t){return"function"==typeof Array.isArray?Array.isArray(t):"[object Array]"===e.call(t)},c=function(n){if(!n||"[object Object]"!==e.call(n))return!1;var r,o=t.call(n,"constructor"),i=n.constructor&&n.constructor.prototype&&t.call(n.constructor.prototype,"isPrototypeOf");if(n.constructor&&!o&&!i)return!1;for(r in n);return void 0===r||t.call(n,r)},f=function(t,e){n&&"__proto__"===e.name?n(t,e.name,{enumerable:!0,configurable:!0,value:e.newValue,writable:!0}):t[e.name]=e.newValue},u=function(e,n){if("__proto__"===n){if(!t.call(e,n))return;if(i)return i(e,n).value}return e[n]};return r=function t(){var e,n,r,o,i,a,p=arguments[0],l=1,h=arguments.length,y=!1;for("boolean"==typeof p&&(y=p,p=arguments[1]||{},l=2),(null==p||"object"!=typeof p&&"function"!=typeof p)&&(p={});l<h;++l)if(null!=(e=arguments[l]))for(n in e)r=u(p,n),p!==(o=u(e,n))&&(y&&o&&(c(o)||(i=s(o)))?(i?(i=!1,a=r&&s(r)?r:[]):a=r&&c(r)?r:{},f(p,{name:n,newValue:t(y,a,o)})):void 0!==o&&f(p,{name:n,newValue:o}));return p}}());function s(t){if("object"!=typeof t||null===t)return!1;const e=Object.getPrototypeOf(t);return!(null!==e&&e!==Object.prototype&&null!==Object.getPrototypeOf(e)||Symbol.toStringTag in t||Symbol.iterator in t)}function c(){const t=[],e={run:function(...e){let n=-1;const r=e.pop();if("function"!=typeof r)throw new TypeError("Expected function as last argument, not "+r);!function o(i,...s){const c=t[++n];let f=-1;if(i)r(i);else{for(;++f<e.length;)null!==s[f]&&void 0!==s[f]||(s[f]=e[f]);e=s,c?function(t,e){let n;return r;function r(...e){const r=t.length>e.length;let c;r&&e.push(o);try{c=t.apply(this,e)}catch(i){if(r&&n)throw i;return o(i)}r||(c&&c.then&&"function"==typeof c.then?c.then(s,o):c instanceof Error?o(c):s(c))}function o(t,...r){n||(n=!0,e(t,...r))}function s(t){o(null,t)}}(c,o)(...s):r(null,...s)}}(null,...e)},use:function(n){if("function"!=typeof n)throw new TypeError("Expected `middelware` to be a function, not "+n);return t.push(n),e}};return e}const f=function(t){const e=this.constructor.prototype,n=e[t],r=function(){return n.apply(r,arguments)};return Object.setPrototypeOf(r,e),r},u={}.hasOwnProperty;class a extends f{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=c()}copy(){const t=new a;let e=-1;for(;++e<this.attachers.length;){const n=this.attachers[e];t.use(...n)}return t.data(i(!0,{},this.namespace)),t}data(t,e){return"string"==typeof t?2===arguments.length?(y("data",this.frozen),this.namespace[t]=e,this):u.call(this.namespace,t)&&this.namespace[t]||void 0:t?(y("data",this.frozen),this.namespace=t,this):this.namespace}freeze(){if(this.frozen)return this;const t=this;for(;++this.freezeIndex<this.attachers.length;){const[e,...n]=this.attachers[this.freezeIndex];if(!1===n[0])continue;!0===n[0]&&(n[0]=void 0);const r=e.call(t,...n);"function"==typeof r&&this.transformers.use(r)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(t){this.freeze();const e=d(t),n=this.parser||this.Parser;return l("parse",n),n(String(e),e)}process(t,e){const n=this;return this.freeze(),l("process",this.parser||this.Parser),h("process",this.compiler||this.Compiler),e?r(void 0,e):new Promise(r);function r(r,o){const i=d(t),s=n.parse(i);function c(t,n){t||!n?o(t):r?r(n):e(void 0,n)}n.run(s,i,(function(t,e,r){if(t||!e||!r)return c(t);const o=e,i=n.stringify(o,r);var s;"string"==typeof(s=i)||function(t){return Boolean(t&&"object"==typeof t&&"byteLength"in t&&"byteOffset"in t)}(s)?r.value=i:r.result=i,c(t,r)}))}}processSync(t){let e,r=!1;return this.freeze(),l("processSync",this.parser||this.Parser),h("processSync",this.compiler||this.Compiler),this.process(t,(function(t,o){r=!0,n(t),e=o})),w("processSync","process",r),e}run(t,e,n){m(t),this.freeze();const r=this.transformers;return n||"function"!=typeof e||(n=e,e=void 0),n?o(void 0,n):new Promise(o);function o(o,i){const s=d(e);r.run(t,s,(function(e,r,s){const c=r||t;e?i(e):o?o(c):n(void 0,c,s)}))}}runSync(t,e){let r,o=!1;return this.run(t,e,(function(t,e){n(t),r=e,o=!0})),w("runSync","run",o),r}stringify(t,e){this.freeze();const n=d(e),r=this.compiler||this.Compiler;return h("stringify",r),m(t),r(t,n)}use(t,...e){const n=this.attachers,r=this.namespace;if(y("use",this.frozen),null==t);else if("function"==typeof t)u(t,e);else{if("object"!=typeof t)throw new TypeError("Expected usable value, not `"+t+"`");Array.isArray(t)?f(t):c(t)}return this;function o(t){if("function"==typeof t)u(t,[]);else{if("object"!=typeof t)throw new TypeError("Expected usable value, not `"+t+"`");if(Array.isArray(t)){const[e,...n]=t;u(e,n)}else c(t)}}function c(t){if(!("plugins"in t)&&!("settings"in t))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");f(t.plugins),t.settings&&(r.settings=i(!0,r.settings,t.settings))}function f(t){let e=-1;if(null==t);else{if(!Array.isArray(t))throw new TypeError("Expected a list of plugins, not `"+t+"`");for(;++e<t.length;){o(t[e])}}}function u(t,e){let r=-1,o=-1;for(;++r<n.length;)if(n[r][0]===t){o=r;break}if(-1===o)n.push([t,...e]);else if(e.length>0){let[r,...c]=e;const f=n[o][1];s(f)&&s(r)&&(r=i(!0,f,r)),n[o]=[t,r,...c]}}}}const p=(new a).freeze();function l(t,e){if("function"!=typeof e)throw new TypeError("Cannot `"+t+"` without `parser`")}function h(t,e){if("function"!=typeof e)throw new TypeError("Cannot `"+t+"` without `compiler`")}function y(t,e){if(e)throw new Error("Cannot call `"+t+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function m(t){if(!s(t)||"string"!=typeof t.type)throw new TypeError("Expected node, got `"+t+"`")}function w(t,e,n){if(!n)throw new Error("`"+t+"` finished async. Use `"+e+"` instead")}function d(t){return function(t){return Boolean(t&&"object"==typeof t&&"message"in t&&"messages"in t)}(t)?t:new e(t)}export{p as unified};
